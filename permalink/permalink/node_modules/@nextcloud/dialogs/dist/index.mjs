import { basename } from "path";
import { spawnDialog as spawnDialog$1 } from "@nextcloud/vue/functions/dialog";
import { t, n, a as normalizeComponent } from "./chunks/_plugin-vue2_normalizer-D_fqBVIr.mjs";
import { h, f, g, d, e, c, T, b, l, k, o, s, i, m, j } from "./chunks/_plugin-vue2_normalizer-D_fqBVIr.mjs";
import { defineComponent, onMounted, onUnmounted } from "vue";
import NcDialog from "@nextcloud/vue/components/NcDialog";
import NcNoteCard from "@nextcloud/vue/components/NcNoteCard";
const IconMove = '<svg xmlns="http://www.w3.org/2000/svg" id="mdi-folder-move" viewBox="0 0 24 24"><path d="M14,18V15H10V11H14V8L19,13M20,6H12L10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6Z" /></svg>';
const IconCopy = '<svg xmlns="http://www.w3.org/2000/svg" id="mdi-folder-multiple" viewBox="0 0 24 24"><path d="M22,4H14L12,2H6A2,2 0 0,0 4,4V16A2,2 0 0,0 6,18H22A2,2 0 0,0 24,16V6A2,2 0 0,0 22,4M2,6H0V11H0V20A2,2 0 0,0 2,22H20V20H2V6Z" /></svg>';
var FilePickerType = /* @__PURE__ */ ((FilePickerType2) => {
  FilePickerType2[FilePickerType2["Choose"] = 1] = "Choose";
  FilePickerType2[FilePickerType2["Move"] = 2] = "Move";
  FilePickerType2[FilePickerType2["Copy"] = 3] = "Copy";
  FilePickerType2[FilePickerType2["CopyMove"] = 4] = "CopyMove";
  FilePickerType2[FilePickerType2["Custom"] = 5] = "Custom";
  return FilePickerType2;
})(FilePickerType || {});
class FilePickerClosed extends Error {
}
class FilePicker {
  title;
  multiSelect;
  mimeTypeFilter;
  directoriesAllowed;
  buttons;
  path;
  filter;
  container;
  disabledNavigation;
  constructor(title, multiSelect, mimeTypeFilter, directoriesAllowed, buttons, path, filter, container, disabledNavigation = false) {
    this.title = title;
    this.multiSelect = multiSelect;
    this.mimeTypeFilter = mimeTypeFilter;
    this.directoriesAllowed = directoriesAllowed;
    this.path = path;
    this.filter = filter;
    this.buttons = buttons;
    this.container = container;
    this.disabledNavigation = disabledNavigation;
  }
  /**
   * Pick files using the FilePicker.
   *
   * @return Promise with array of picked files or rejected promise on close without picking
   */
  async pickNodes() {
    const { FilePickerVue } = await import("./chunks/index-Cp_Wd5Qd.mjs");
    return new Promise((resolve, reject) => {
      spawnDialog$1(FilePickerVue, {
        allowPickDirectory: this.directoriesAllowed,
        buttons: this.buttons,
        container: this.container,
        name: this.title,
        path: this.path,
        mimetypeFilter: this.mimeTypeFilter,
        multiselect: this.multiSelect,
        filterFn: this.filter,
        disabledNavigation: this.disabledNavigation
      }, (...rest) => {
        const [nodes] = rest;
        if (!Array.isArray(nodes) || nodes.length === 0) {
          reject(new FilePickerClosed("FilePicker: No nodes selected"));
        } else {
          resolve(nodes);
        }
      });
    });
  }
  /**
   * Pick files using the FilePicker
   *
   * @return Promise with array of paths of picked files or rejected promise on close without picking
   */
  async pick() {
    const nodes = await this.pickNodes();
    if (this.multiSelect) {
      return nodes[0]?.path ?? "/";
    }
    return nodes.map((node) => node.path);
  }
}
class FilePickerBuilder {
  title;
  multiSelect = false;
  mimeTypeFilter = [];
  directoriesAllowed = false;
  path;
  filter;
  buttons = [];
  container;
  disabledNavigation = false;
  /**
   * Construct a new FilePicker
   *
   * @param title Title of the FilePicker
   */
  constructor(title) {
    this.title = title;
  }
  /**
   * Set the container where the FilePicker will be mounted
   * By default 'body' is used
   *
   * @param container The dialog container
   */
  setContainer(container) {
    this.container = container;
    return this;
  }
  /**
   * Enable or disable picking multiple files
   *
   * @param ms True to enable picking multiple files, false otherwise
   */
  setMultiSelect(ms) {
    this.multiSelect = ms;
    return this;
  }
  /**
   * Add allowed MIME type
   *
   * @param filter MIME type to allow
   */
  addMimeTypeFilter(filter) {
    this.mimeTypeFilter.push(filter);
    return this;
  }
  /**
   * Set allowed MIME types
   *
   * @param filter Array of allowed MIME types
   */
  setMimeTypeFilter(filter) {
    this.mimeTypeFilter = filter;
    return this;
  }
  /**
   * Add a button to the FilePicker
   * Note: This overrides any previous `setButtonFactory` call
   *
   * @param button The button
   */
  addButton(button) {
    if (typeof this.buttons === "function") {
      console.warn("FilePicker buttons were set to factory, now overwritten with button object.");
      this.buttons = [];
    }
    this.buttons.push(button);
    return this;
  }
  /**
   * Set the button factory which is used to generate buttons from current view, path and selected nodes
   * Note: This overrides any previous `addButton` call
   *
   * @param factory The button factory
   */
  setButtonFactory(factory) {
    this.buttons = factory;
    return this;
  }
  /**
   * Set FilePicker type based on legacy file picker types
   * @param type The legacy filepicker type to emulate
   * @deprecated Use `addButton` or `setButtonFactory` instead as with setType you do not know which button was pressed
   */
  setType(type) {
    this.buttons = (nodes, path) => {
      const buttons = [];
      const node = nodes?.[0]?.attributes?.displayName || nodes?.[0]?.basename;
      const target = node || basename(path);
      if (type === 1) {
        let label = t("Choose");
        if (nodes.length === 1) {
          label = t("Choose {file}", { file: node });
        } else if (this.multiSelect) {
          label = n("Choose %n file", "Choose %n files", nodes.length);
        }
        buttons.push({
          callback: () => {
          },
          type: "primary",
          label
        });
      }
      if (type === 4 || type === 3) {
        buttons.push({
          callback: () => {
          },
          label: target ? t("Copy to {target}", { target }) : t("Copy"),
          type: "primary",
          icon: IconCopy
        });
      }
      if (type === 2 || type === 4) {
        buttons.push({
          callback: () => {
          },
          label: target ? t("Move to {target}", { target }) : t("Move"),
          type: type === 2 ? "primary" : "secondary",
          icon: IconMove
        });
      }
      return buttons;
    };
    return this;
  }
  /**
   * Allow to pick directories besides files
   *
   * @param allow True to allow picking directories
   */
  allowDirectories(allow = true) {
    this.directoriesAllowed = allow;
    return this;
  }
  /**
   * Set starting path of the FilePicker
   *
   * @param path Path to start from picking
   */
  startAt(path) {
    this.path = path;
    return this;
  }
  /**
   * Add filter function to filter file list of FilePicker
   *
   * @param filter Filter function to apply
   */
  setFilter(filter) {
    this.filter = filter;
    return this;
  }
  /**
   * Disable navigation (view selection)
   */
  disableNavigation() {
    this.disabledNavigation = true;
    return this;
  }
  /**
   * Construct the configured FilePicker
   */
  build() {
    return new FilePicker(
      this.title,
      this.multiSelect,
      this.mimeTypeFilter,
      this.directoriesAllowed,
      this.buttons,
      this.path,
      this.filter,
      this.container,
      this.disabledNavigation
    );
  }
}
function getFilePickerBuilder(title) {
  return new FilePickerBuilder(title);
}
const spawnDialog = spawnDialog$1;
var DialogSeverity = /* @__PURE__ */ ((DialogSeverity2) => {
  DialogSeverity2["Info"] = "info";
  DialogSeverity2["Warning"] = "warning";
  DialogSeverity2["Error"] = "error";
  return DialogSeverity2;
})(DialogSeverity || {});
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "GenericDialog",
  props: {
    name: null,
    text: null,
    html: null,
    buttons: null,
    severity: null
  },
  setup(__props) {
    const props = __props;
    const handleUnload = () => `${props.name}: ${props.text}`;
    onMounted(() => window.addEventListener("unload", handleUnload));
    onUnmounted(() => window.removeEventListener("unload", handleUnload));
    return { __sfc: true, props, handleUnload, NcDialog, NcNoteCard };
  }
});
var _sfc_render = function render() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c(_setup.NcDialog, { attrs: { "dialog-classes": "nc-generic-dialog", "buttons": _vm.buttons, "name": _vm.name, "message": _vm.text }, on: { "update:open": function($event) {
    return _vm.$emit("close");
  } } }, [_vm.severity ? _c(_setup.NcNoteCard, { attrs: { "type": _vm.severity } }, [_c("p", { domProps: { "textContent": _vm._s(_vm.text) } })]) : _vm._e(), _vm.html ? _c("div", { domProps: { "innerHTML": _vm._s(_vm.html) } }) : _vm._e()], 1);
};
var _sfc_staticRenderFns = [];
var __component__ = /* @__PURE__ */ normalizeComponent(
  _sfc_main,
  _sfc_render,
  _sfc_staticRenderFns,
  false,
  null,
  null
);
const GenericDialog = __component__.exports;
class Dialog {
  #name;
  #text;
  #buttons;
  #severity;
  #dialog;
  /** @deprecated */
  #html;
  constructor(name, text, buttons = [], severity) {
    this.#name = name;
    this.#text = text;
    this.#buttons = buttons;
    this.#severity = severity;
    this.#dialog = void 0;
    this.#html = void 0;
  }
  /**
   * @deprecated DO NOT USE! It will be removed in the near future!
   * @param html HTML content
   */
  setHTML(html) {
    this.#html = html;
    return this;
  }
  /**
   * Spawn and show the dialog - if already open the previous instance will be destroyed
   * @return Promise that resolves when the dialog is answered successfully and rejects on close
   */
  async show() {
    if (this.#dialog) {
      this.#dialog.$destroy();
    }
    return new Promise((resolve) => {
      this.#dialog = spawnDialog$1(
        GenericDialog,
        {
          buttons: this.#buttons,
          name: this.#name,
          text: this.#text,
          severity: this.#severity,
          html: this.#html
        },
        resolve
      );
    });
  }
  /**
   * Hide and destroy the current dialog instance
   *
   * @deprecated use the promise of the `show` methods for the user interaction.
   */
  hide() {
    this.#dialog?.$destroy();
  }
}
class DialogBuilder {
  #severity;
  #text;
  #name;
  #buttons;
  constructor(name) {
    this.#severity = void 0;
    this.#text = "";
    this.#name = name ?? "";
    this.#buttons = [];
  }
  /**
   * Set dialog name
   * @param name The name or headline of the dialog
   */
  setName(name) {
    this.#name = name;
    return this;
  }
  /**
   * Set the dialog text
   * @param text Main text of the dialog
   */
  setText(text) {
    this.#text = text;
    return this;
  }
  /**
   * Set the severity of the dialog
   * @param severity Severity of the dialog
   */
  setSeverity(severity) {
    this.#severity = severity;
    return this;
  }
  /**
   * Set buttons from array
   * @param buttons Either an array of dialog buttons
   */
  setButtons(buttons) {
    if (this.#buttons.length > 0) {
      console.warn("[@nextcloud/dialogs] Dialog buttons are already set - this overrides previous buttons.");
    }
    this.#buttons = buttons;
    return this;
  }
  /**
   * Add a single button
   * @param button Button to add
   */
  addButton(button) {
    this.#buttons.push(button);
    return this;
  }
  build() {
    return new Dialog(this.#name, this.#text, this.#buttons, this.#severity);
  }
}
function getDialogBuilder(name) {
  return new DialogBuilder(name);
}
export {
  Dialog,
  DialogBuilder,
  DialogSeverity,
  FilePicker,
  FilePickerBuilder,
  FilePickerClosed,
  FilePickerType,
  h as TOAST_ARIA_LIVE_ASSERTIVE,
  f as TOAST_ARIA_LIVE_OFF,
  g as TOAST_ARIA_LIVE_POLITE,
  d as TOAST_DEFAULT_TIMEOUT,
  e as TOAST_PERMANENT_TIMEOUT,
  c as TOAST_UNDO_TIMEOUT,
  T as ToastAriaLive,
  b as ToastType,
  getDialogBuilder,
  getFilePickerBuilder,
  l as showError,
  k as showInfo,
  o as showLoading,
  s as showMessage,
  i as showSuccess,
  m as showUndo,
  j as showWarning,
  spawnDialog
};
//# sourceMappingURL=index.mjs.map
